// PHOBOS Compositor + Window Manager Skeleton - WHAT THIS FILE NEEDS TO DO
//
// ===========================================================
// 1. Window Class (represents a single window)
// -----------------------------------------------------------
// - Track window position (x, y), size (width, height)
// - Track logical properties:
//     - zIndex (stacking order)
//     - focused (is it active?)
//     - visible (hidden/minimized)
// - Track rendering info:
//     - buffer pointer (pixel data)
//     - decorations info (titlebar, borders, colors)
// - Track client/app reference:
//     - clientHandle (pointer to PHOBOS app or Wayland-like surface)
// - Methods:
//     - move(x, y)
//     - resize(width, height)
//     - optionally: toggle focus, toggle visibility
// - Notes: The window itself does NOT draw anything, just holds info.

external string malloc(int size)
external string realloc(string ptr, int size)

external int render_rect_needs_redraw(int x, int y, int w, int h)
external int render_width()
external int render_height()
external int deimos_split_x(int index)
external int deimos_split_y(int index)
external int deimos_split_target_mode(int index)
external int deimos_split_target_id(int index)
external int deimos_window_is_floating(int index)
external int deimos_window_float_x(int index)
external int deimos_window_float_y(int index)
external int deimos_window_float_w(int index)
external int deimos_window_float_h(int index)
external int deimos_focus_window_id()
external int deimos_theme_window_color()
external int deimos_theme_window_focus_color()
external int deimos_theme_gap()
external int deimos_split_vertical_bias_percent()
external int deimos_split_force_mode()
external void deimos_report_window_rect(int index, int id, int x, int y, int w, int h)
external int deimos_should_draw_windows()
external int deimos_should_draw_layout_window(int window_id)
external void deimos_draw_window_frame(int window_id, int x, int y, int w, int h, int focused)


class Window {
    // fields and constructor
    int id = -1
    int x = 0
    int y = 0
    int w = 0
    int h = 0
    int z_index = 0
    bool focused = false
    bool visible = true

    func new(int xpos = 0, int ypos = 0, int width = 0, int height = 0) {
        set this.x = xpos
        set this.y = ypos
        set this.w = width
        set this.h = height
    }

    // methods
    void move(int to_x, int to_y) {
        set this.x = to_x
        set this.y = to_y
    }

    void resize(int width, int height) {
        set this.w = width
        set this.h = height
    }

    void show() {
        set this.visible = true
    }

    void hide() {
        set this.visible = false
    }
}

// ===========================================================
// 3. Compositor Class (responsible for drawing)
// -----------------------------------------------------------
// - Stores list of windows (manual array or fixed-size array if no STL)
// - Responsible for:
//     - rendering windows in z-index order
//     - drawing decorations (borders, titlebars, shadows)
//     - handling raw framebuffer / GPU buffers
//     - presenting the final frame to the screen
//     - optionally: effects like transparency, fade, animations
// - Methods:
//     - addWindow(Window* win)
//     - removeWindow(Window* win)
//     - render()  // main draw function
//     - drawWindow(Window* win) // helper to draw individual window + decorations
//     - optionally: drawDecorations(Window* win), drawShadow(Window* win)
// - Notes:
//     - Compositor may sort windows by zIndex before drawing
//     - Reads window fields set by WM to know where/how to draw
//     - Could handle input forwarding (or leave that to WM)

class Compositor {
    array<Window> windows = []
    int next_window_id = 1

    // methods
    int add_window(Window win) {
        if (this.windows.length() >= 16) {
            return -1
        }

        set win.id = this.next_window_id
        set this.next_window_id = this.next_window_id + 1
        this.windows.append(win)
        return win.id
    }
    bool remove_window(int window_id){
        array<Window> kept = []
        bool removed = false

        for (window in this.windows){
            if (window.id == window_id){
                set removed = true
            } else {
                kept.append(window)
            }
        }

        if (removed){
            set this.windows = kept
        }
        return removed
    }

    int rgb(int r, int g, int b) {
        return (r * 65536) + (g * 256) + b
    }

    void layout_split_points() {
        int n = this.windows.length()
        if (n <= 0) {
            return
        }

        int area_x = 8
        int area_y = 28
        int area_w = render_width() - (area_x * 2)
        int area_h = render_height() - area_y - 8
        if (area_w < 1) {
            set area_w = 1
        }
        if (area_h < 1) {
            set area_h = 1
        }

        array<int> rect_x = []
        array<int> rect_y = []
        array<int> rect_w = []
        array<int> rect_h = []
        array<int> rect_parent_split = []  // 0 none, 1 vertical, 2 horizontal

        rect_x.append(area_x)
        rect_y.append(area_y)
        rect_w.append(area_w)
        rect_h.append(area_h)
        rect_parent_split.append(0)

        int i = 1
        while (i < n) {
            int px = deimos_split_x(i)
            int py = deimos_split_y(i)
            int target = 0

            int mode = deimos_split_target_mode(i)
            int j = 0
            bool found_target = false
            if (mode == 1) {
                int target_id = deimos_split_target_id(i)
                while (j < i) {
                    if (this.windows[j].id == target_id) {
                        set target = j
                        set found_target = true
                    }
                    if (found_target) {
                        set j = i
                    } else {
                        set j = j + 1
                    }
                }
            }

            if (found_target == false) {
                set j = 0
                while (j < i) {
                    int tx = rect_x[j]
                    int ty = rect_y[j]
                    int tw = rect_w[j]
                    int th = rect_h[j]

                    if (px >= tx) {
                        if (px < tx + tw) {
                            if (py >= ty) {
                                if (py < ty + th) {
                                    set target = j
                                    set found_target = true
                                }
                            }
                        }
                    }
                    if (found_target) {
                        set j = i
                    } else {
                        set j = j + 1
                    }
                }
            }

            int tx = rect_x[target]
            int ty = rect_y[target]
            int tw = rect_w[target]
            int th = rect_h[target]

            bool split_vertical = true
            int split_force = deimos_split_force_mode()
            if (split_force == 1) {
                set split_vertical = true
            } elif (split_force == 2) {
                set split_vertical = false
            } else {
                int bias = deimos_split_vertical_bias_percent()
                int parent_split = rect_parent_split[target]

                if ((tw * 100) > (th * bias)) {
                    set split_vertical = true
                } elif ((th * 100) > (tw * bias)) {
                    set split_vertical = false
                } else {
                    if (parent_split == 1) {
                        set split_vertical = false
                    } elif (parent_split == 2) {
                        set split_vertical = true
                    } else {
                        set split_vertical = true
                    }
                }

                // Keep splits sane when one axis is already too constrained.
                if (tw < 64) {
                    set split_vertical = false
                }
                if (th < 48) {
                    set split_vertical = true
                }
            }

            if (split_vertical) {
                int split = tw / 2
                int min_w = tw / 5
                if (min_w < 32) {
                    set min_w = 32
                }
                int max_w = tw - min_w
                if (max_w < 1) {
                    set max_w = 1
                }
                if (split < min_w) {
                    set split = min_w
                }
                if (split > max_w) {
                    set split = max_w
                }

                int left_x = tx
                int left_y = ty
                int left_w = split
                int left_h = th

                int right_x = tx + split
                int right_y = ty
                int right_w = tw - split
                int right_h = th

                if (right_w < 1) {
                    set right_w = 1
                    set left_w = tw - 1
                }
                if (left_w < 1) {
                    set left_w = 1
                    set right_w = tw - 1
                }

                if (px < right_x) {
                    set rect_x[target] = right_x
                    set rect_y[target] = right_y
                    set rect_w[target] = right_w
                    set rect_h[target] = right_h
                    set rect_parent_split[target] = 1

                    rect_x.append(left_x)
                    rect_y.append(left_y)
                    rect_w.append(left_w)
                    rect_h.append(left_h)
                    rect_parent_split.append(1)
                } else {
                    set rect_x[target] = left_x
                    set rect_y[target] = left_y
                    set rect_w[target] = left_w
                    set rect_h[target] = left_h
                    set rect_parent_split[target] = 1

                    rect_x.append(right_x)
                    rect_y.append(right_y)
                    rect_w.append(right_w)
                    rect_h.append(right_h)
                    rect_parent_split.append(1)
                }
            } else {
                int split = th / 2
                int min_h = th / 5
                if (min_h < 24) {
                    set min_h = 24
                }
                int max_h = th - min_h
                if (max_h < 1) {
                    set max_h = 1
                }
                if (split < min_h) {
                    set split = min_h
                }
                if (split > max_h) {
                    set split = max_h
                }

                int top_x = tx
                int top_y = ty
                int top_w = tw
                int top_h = split

                int bottom_x = tx
                int bottom_y = ty + split
                int bottom_w = tw
                int bottom_h = th - split

                if (bottom_h < 1) {
                    set bottom_h = 1
                    set top_h = th - 1
                }
                if (top_h < 1) {
                    set top_h = 1
                    set bottom_h = th - 1
                }

                if (py < bottom_y) {
                    set rect_x[target] = bottom_x
                    set rect_y[target] = bottom_y
                    set rect_w[target] = bottom_w
                    set rect_h[target] = bottom_h
                    set rect_parent_split[target] = 2

                    rect_x.append(top_x)
                    rect_y.append(top_y)
                    rect_w.append(top_w)
                    rect_h.append(top_h)
                    rect_parent_split.append(2)
                } else {
                    set rect_x[target] = top_x
                    set rect_y[target] = top_y
                    set rect_w[target] = top_w
                    set rect_h[target] = top_h
                    set rect_parent_split[target] = 2

                    rect_x.append(bottom_x)
                    rect_y.append(bottom_y)
                    rect_w.append(bottom_w)
                    rect_h.append(bottom_h)
                    rect_parent_split.append(2)
                }
            }

            set i = i + 1
        }

        set i = 0
        while (i < n) {
            int gap = deimos_theme_gap()
            int draw_x = 0
            int draw_y = 0
            int draw_w = 1
            int draw_h = 1

            if (deimos_window_is_floating(i) != 0) {
                set draw_x = deimos_window_float_x(i)
                set draw_y = deimos_window_float_y(i)
                set draw_w = deimos_window_float_w(i)
                set draw_h = deimos_window_float_h(i)

                if (draw_w < 40) { set draw_w = 40 }
                if (draw_h < 28) { set draw_h = 28 }
            } else {
                set draw_x = rect_x[i] + gap
                set draw_y = rect_y[i] + gap
                set draw_w = rect_w[i] - (gap * 2)
                set draw_h = rect_h[i] - (gap * 2)
                if (draw_w < 1) {
                    set draw_w = 1
                }
                if (draw_h < 1) {
                    set draw_h = 1
                }
            }

            Window win = this.windows[i]
            set win.x = draw_x
            set win.y = draw_y
            set win.w = draw_w
            set win.h = draw_h
            set this.windows[i] = win

            set i = i + 1
        }
    }

    void render(){
        int focused_id = deimos_focus_window_id()
        int should_draw = deimos_should_draw_windows()
        int i = 0
        while (i < this.windows.length()) {
            Window win = this.windows[i]
            deimos_report_window_rect(i, win.id, win.x, win.y, win.w, win.h)
            if (should_draw != 0 &&
                deimos_should_draw_layout_window(win.id) != 0 &&
                render_rect_needs_redraw(win.x, win.y, win.w, win.h) != 0) {
                int is_focused = 0
                if (win.id == focused_id) {
                    set is_focused = 1
                }
                deimos_draw_window_frame(win.id, win.x, win.y, win.w, win.h, is_focused)
            }
            set i = i + 1
        }
    }
}

int deimos_compositor_test_frame_with_count(int window_count) {
    Compositor comp = new Compositor()

    int count = window_count
    if (count < 0) {
        set count = 0
    }
    if (count > 16) {
        set count = 16
    }

    int i = 0
    while (i < count) {
        Window win = new Window(0, 0, 1, 1)
        set win.z_index = i + 1
        comp.add_window(win)
        set i = i + 1
    }

    comp.layout_split_points()
    comp.render()
    return count
}

int deimos_compositor_test_frame() {
    return deimos_compositor_test_frame_with_count(2)
}

// ===========================================================
// 5. Frame / Rendering Loop
// -----------------------------------------------------------
// - Initialize framebuffer / GPU
// - Main loop:
//     - poll input events
//     - update WM state (focus, move, resize, layout)
//     - compositor.render() to draw all windows
//     - present the frame
// - Optional:
//     - damage tracking: only redraw areas that changed
//     - smooth animations / effects



// ===========================================================
// 6. Decorations & Effects (Compositor responsibility)
// -----------------------------------------------------------
// - Draw titlebars/borders based on window.focused
// - Shadows, transparency, fade-in/out
// - Optional animations: resizing, moving, tiling





// ===========================================================
// 8. Modular Notes
// -----------------------------------------------------------
// - Keep WM logic separate from rendering logic:
//     - WM decides what happens
//     - Compositor decides how it looks
// - Window class is shared between them
// - Input can go through WM, compositor, or both
// - Everything should be STL-free if desired:
//     - Use fixed-size arrays or manual memory management
// - Start simple:
//     - Draw rectangles as windows first
//     - Add focus, stacking, move/resize
//     - Add decorations
//     - Add effects later



// ===========================================================
// 9. Optional Features to Add After Core Works
// -----------------------------------------------------------
// - Multiple workspaces / virtual desktops
// - Tiling layouts
// - Mouse-based window move/resize
// - Animations (fade, slide, scale)
// - Transparency, shadows
// - Wayland or networked client support



// ===========================================================
// 10. Suggested Development Flow
// -----------------------------------------------------------
// 1. Make a Window class and simple array of windows
// 2. Make Compositor class that draws rectangles
// 3. Make WindowManager class that can focus/move/resize windows
// 4. Integrate input: move focus, move windows with keys
// 5. Add decorations
// 6. Add z-index sorting
// 7. Add effects/animations
// 8. Expand to multiple workspaces, tiling layouts
// 9. Optionally hook in real clients or Wayland buffers
