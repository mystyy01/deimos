// PHOBOS Compositor + Window Manager Skeleton - WHAT THIS FILE NEEDS TO DO
//
// ===========================================================
// 1. Window Class (represents a single window)
// -----------------------------------------------------------
// - Track window position (x, y), size (width, height)
// - Track logical properties:
//     - zIndex (stacking order)
//     - focused (is it active?)
//     - visible (hidden/minimized)
// - Track rendering info:
//     - buffer pointer (pixel data)
//     - decorations info (titlebar, borders, colors)
// - Track client/app reference:
//     - clientHandle (pointer to PHOBOS app or Wayland-like surface)
// - Methods:
//     - move(x, y)
//     - resize(width, height)
//     - optionally: toggle focus, toggle visibility
// - Notes: The window itself does NOT draw anything, just holds info.

external string malloc(int size)
external string realloc(string ptr, int size)

external void render_draw_rect(int x, int y, int w, int h, int colour)


class Window {
    // fields and constructor
    int id = -1
    int x = 0
    int y = 0
    int w = 0
    int h = 0
    int z_index = 0
    bool focused = false
    bool visible = true

    func new(int xpos = 0, int ypos = 0, int width = 0, int height = 0) {
        set this.x = xpos
        set this.y = ypos
        set this.w = width
        set this.h = height
    }

    // methods
    void move(int to_x, int to_y) {
        set this.x = to_x
        set this.y = to_y
    }

    void resize(int width, int height) {
        set this.w = width
        set this.h = height
    }

    void show() {
        set this.visible = true
    }

    void hide() {
        set this.visible = false
    }
}

// ===========================================================
// 3. Compositor Class (responsible for drawing)
// -----------------------------------------------------------
// - Stores list of windows (manual array or fixed-size array if no STL)
// - Responsible for:
//     - rendering windows in z-index order
//     - drawing decorations (borders, titlebars, shadows)
//     - handling raw framebuffer / GPU buffers
//     - presenting the final frame to the screen
//     - optionally: effects like transparency, fade, animations
// - Methods:
//     - addWindow(Window* win)
//     - removeWindow(Window* win)
//     - render()  // main draw function
//     - drawWindow(Window* win) // helper to draw individual window + decorations
//     - optionally: drawDecorations(Window* win), drawShadow(Window* win)
// - Notes:
//     - Compositor may sort windows by zIndex before drawing
//     - Reads window fields set by WM to know where/how to draw
//     - Could handle input forwarding (or leave that to WM)

class Compositor {
    array<Window> windows = []
    int next_window_id = 1

    // methods
    int add_window(Window win) {
        if (this.windows.length() >= 16) {
            return -1
        }

        set win.id = this.next_window_id
        set this.next_window_id = this.next_window_id + 1
        this.windows.append(win)
        return win.id
    }
    bool remove_window(int window_id){
        array<Window> kept = []
        bool removed = false

        for (window in this.windows){
            if (window.id == window_id){
                set removed = true
            } else {
                kept.append(window)
            }
        }

        if (removed){
            set this.windows = kept
        }
        return removed
    }

    int rgb(int r, int g, int b) {
        return (r * 65536) + (g * 256) + b
    }

    void render(){
        array<int> order = []

        // Collect visible windows by index.
        int i = 0
        while (i < this.windows.length()) {
            if (this.windows[i].visible) {
                order.append(i)
            }
            set i = i + 1
        }

        // Insertion sort by z-index (low to high).
        set i = 1
        while (i < order.length()) {
            int key = order[i]
            int j = i - 1

            while (j >= 0 && this.windows[order[j]].z_index > this.windows[key].z_index) {
                set order[j + 1] = order[j]
                set j = j - 1
            }

            set order[j + 1] = key
            set i = i + 1
        }

        // Draw in sorted order. Highest z-index is drawn last.
        set i = 0
        while (i < order.length()) {
            Window win = this.windows[order[i]]
            int window_colour = this.rgb(0, 170, 102)
            render_draw_rect(win.x, win.y, win.w, win.h, window_colour)
            set i = i + 1
        }
    }
}

int deimos_compositor_test_frame_with_count(int window_count) {
    Compositor comp = new Compositor()

    int count = window_count
    if (count < 0) {
        set count = 0
    }
    if (count > 16) {
        set count = 16
    }

    int i = 0
    while (i < count) {
        int x = 80 + (i * 28)
        int y = 80 + (i * 20)
        Window win = new Window(x, y, 260, 150)
        set win.z_index = i + 1
        comp.add_window(win)
        set i = i + 1
    }

    comp.render()
    return count
}

int deimos_compositor_test_frame() {
    return deimos_compositor_test_frame_with_count(2)
}

// ===========================================================
// 5. Frame / Rendering Loop
// -----------------------------------------------------------
// - Initialize framebuffer / GPU
// - Main loop:
//     - poll input events
//     - update WM state (focus, move, resize, layout)
//     - compositor.render() to draw all windows
//     - present the frame
// - Optional:
//     - damage tracking: only redraw areas that changed
//     - smooth animations / effects



// ===========================================================
// 6. Decorations & Effects (Compositor responsibility)
// -----------------------------------------------------------
// - Draw titlebars/borders based on window.focused
// - Shadows, transparency, fade-in/out
// - Optional animations: resizing, moving, tiling





// ===========================================================
// 8. Modular Notes
// -----------------------------------------------------------
// - Keep WM logic separate from rendering logic:
//     - WM decides what happens
//     - Compositor decides how it looks
// - Window class is shared between them
// - Input can go through WM, compositor, or both
// - Everything should be STL-free if desired:
//     - Use fixed-size arrays or manual memory management
// - Start simple:
//     - Draw rectangles as windows first
//     - Add focus, stacking, move/resize
//     - Add decorations
//     - Add effects later



// ===========================================================
// 9. Optional Features to Add After Core Works
// -----------------------------------------------------------
// - Multiple workspaces / virtual desktops
// - Tiling layouts
// - Mouse-based window move/resize
// - Animations (fade, slide, scale)
// - Transparency, shadows
// - Wayland or networked client support



// ===========================================================
// 10. Suggested Development Flow
// -----------------------------------------------------------
// 1. Make a Window class and simple array of windows
// 2. Make Compositor class that draws rectangles
// 3. Make WindowManager class that can focus/move/resize windows
// 4. Integrate input: move focus, move windows with keys
// 5. Add decorations
// 6. Add z-index sorting
// 7. Add effects/animations
// 8. Expand to multiple workspaces, tiling layouts
// 9. Optionally hook in real clients or Wayland buffers
