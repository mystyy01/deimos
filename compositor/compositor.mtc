// PHOBOS Compositor + Window Manager Skeleton - WHAT THIS FILE NEEDS TO DO
//
// ===========================================================
// 1. Window Class (represents a single window)
// -----------------------------------------------------------
// - Track window position (x, y), size (width, height)
// - Track logical properties:
//     - zIndex (stacking order)
//     - focused (is it active?)
//     - visible (hidden/minimized)
// - Track rendering info:
//     - buffer pointer (pixel data)
//     - decorations info (titlebar, borders, colors)
// - Track client/app reference:
//     - clientHandle (pointer to PHOBOS app or Wayland-like surface)
// - Methods:
//     - move(x, y)
//     - resize(width, height)
//     - optionally: toggle focus, toggle visibility
// - Notes: The window itself does NOT draw anything, just holds info.

external string malloc(int size)
external string realloc(string ptr, int size)

external void render_draw_rect(int x, int y, int w, int h, int colour)
external int render_width()
external int render_height()


class Window {
    // fields and constructor
    int id = -1
    int x = 0
    int y = 0
    int w = 0
    int h = 0
    int z_index = 0
    bool focused = false
    bool visible = true

    func new(int xpos = 0, int ypos = 0, int width = 0, int height = 0) {
        set this.x = xpos
        set this.y = ypos
        set this.w = width
        set this.h = height
    }

    // methods
    void move(int to_x, int to_y) {
        set this.x = to_x
        set this.y = to_y
    }

    void resize(int width, int height) {
        set this.w = width
        set this.h = height
    }

    void show() {
        set this.visible = true
    }

    void hide() {
        set this.visible = false
    }
}

// ===========================================================
// 3. Compositor Class (responsible for drawing)
// -----------------------------------------------------------
// - Stores list of windows (manual array or fixed-size array if no STL)
// - Responsible for:
//     - rendering windows in z-index order
//     - drawing decorations (borders, titlebars, shadows)
//     - handling raw framebuffer / GPU buffers
//     - presenting the final frame to the screen
//     - optionally: effects like transparency, fade, animations
// - Methods:
//     - addWindow(Window* win)
//     - removeWindow(Window* win)
//     - render()  // main draw function
//     - drawWindow(Window* win) // helper to draw individual window + decorations
//     - optionally: drawDecorations(Window* win), drawShadow(Window* win)
// - Notes:
//     - Compositor may sort windows by zIndex before drawing
//     - Reads window fields set by WM to know where/how to draw
//     - Could handle input forwarding (or leave that to WM)

class Compositor {
    array<Window> windows = []
    int next_window_id = 1

    // methods
    int add_window(Window win) {
        if (this.windows.length() >= 16) {
            return -1
        }

        set win.id = this.next_window_id
        set this.next_window_id = this.next_window_id + 1
        this.windows.append(win)
        return win.id
    }
    bool remove_window(int window_id){
        array<Window> kept = []
        bool removed = false

        for (window in this.windows){
            if (window.id == window_id){
                set removed = true
            } else {
                kept.append(window)
            }
        }

        if (removed){
            set this.windows = kept
        }
        return removed
    }

    int rgb(int r, int g, int b) {
        return (r * 65536) + (g * 256) + b
    }

    void layout_bsp_range(int first_index, int count, int x, int y, int w, int h) {
        if (count <= 0) {
            return
        }

        if (count == 1) {
            int gap = 6
            int draw_x = x + gap
            int draw_y = y + gap
            int draw_w = w - (gap * 2)
            int draw_h = h - (gap * 2)
            if (draw_w < 1) {
                set draw_w = 1
            }
            if (draw_h < 1) {
                set draw_h = 1
            }

            Window win = this.windows[first_index]
            set win.x = draw_x
            set win.y = draw_y
            set win.w = draw_w
            set win.h = draw_h
            set this.windows[first_index] = win
            return
        }

        int left_count = count / 2
        if (left_count < 1) {
            set left_count = 1
        }
        int right_count = count - left_count

        bool split_vertical = true
        if (h > w) {
            set split_vertical = false
        }

        if (split_vertical) {
            int left_w = w / 2
            if (left_w < 1) {
                set left_w = 1
            }
            int right_w = w - left_w
            if (right_w < 1) {
                set right_w = 1
                set left_w = w - right_w
            }

            this.layout_bsp_range(first_index, left_count, x, y, left_w, h)
            this.layout_bsp_range(first_index + left_count, right_count, x + left_w, y, right_w, h)
            return
        }

        int top_h = h / 2
        if (top_h < 1) {
            set top_h = 1
        }
        int bottom_h = h - top_h
        if (bottom_h < 1) {
            set bottom_h = 1
            set top_h = h - bottom_h
        }

        this.layout_bsp_range(first_index, left_count, x, y, w, top_h)
        this.layout_bsp_range(first_index + left_count, right_count, x, y + top_h, w, bottom_h)
    }

    void layout_bsp_screen() {
        int n = this.windows.length()
        if (n <= 0) {
            return
        }

        int area_x = 8
        int area_y = 28
        int area_w = render_width() - (area_x * 2)
        int area_h = render_height() - area_y - 8
        if (area_w < 1) {
            set area_w = 1
        }
        if (area_h < 1) {
            set area_h = 1
        }

        this.layout_bsp_range(0, n, area_x, area_y, area_w, area_h)
    }

    void render(){
        int i = 0
        while (i < this.windows.length()) {
            Window win = this.windows[i]
            int window_colour = this.rgb(0, 170, 102)
            if (win.focused) {
                set window_colour = this.rgb(255, 255, 255)
            }
            render_draw_rect(win.x, win.y, win.w, win.h, window_colour)
            set i = i + 1
        }
    }
}

int deimos_compositor_test_frame_with_count(int window_count) {
    Compositor comp = new Compositor()

    int count = window_count
    if (count < 0) {
        set count = 0
    }
    if (count > 16) {
        set count = 16
    }

    int i = 0
    while (i < count) {
        Window win = new Window(0, 0, 1, 1)
        set win.z_index = i + 1
        if (i == count - 1) {
            set win.focused = true
        }
        comp.add_window(win)
        set i = i + 1
    }

    comp.layout_bsp_screen()
    comp.render()
    return count
}

int deimos_compositor_test_frame() {
    return deimos_compositor_test_frame_with_count(2)
}

// ===========================================================
// 5. Frame / Rendering Loop
// -----------------------------------------------------------
// - Initialize framebuffer / GPU
// - Main loop:
//     - poll input events
//     - update WM state (focus, move, resize, layout)
//     - compositor.render() to draw all windows
//     - present the frame
// - Optional:
//     - damage tracking: only redraw areas that changed
//     - smooth animations / effects



// ===========================================================
// 6. Decorations & Effects (Compositor responsibility)
// -----------------------------------------------------------
// - Draw titlebars/borders based on window.focused
// - Shadows, transparency, fade-in/out
// - Optional animations: resizing, moving, tiling





// ===========================================================
// 8. Modular Notes
// -----------------------------------------------------------
// - Keep WM logic separate from rendering logic:
//     - WM decides what happens
//     - Compositor decides how it looks
// - Window class is shared between them
// - Input can go through WM, compositor, or both
// - Everything should be STL-free if desired:
//     - Use fixed-size arrays or manual memory management
// - Start simple:
//     - Draw rectangles as windows first
//     - Add focus, stacking, move/resize
//     - Add decorations
//     - Add effects later



// ===========================================================
// 9. Optional Features to Add After Core Works
// -----------------------------------------------------------
// - Multiple workspaces / virtual desktops
// - Tiling layouts
// - Mouse-based window move/resize
// - Animations (fade, slide, scale)
// - Transparency, shadows
// - Wayland or networked client support



// ===========================================================
// 10. Suggested Development Flow
// -----------------------------------------------------------
// 1. Make a Window class and simple array of windows
// 2. Make Compositor class that draws rectangles
// 3. Make WindowManager class that can focus/move/resize windows
// 4. Integrate input: move focus, move windows with keys
// 5. Add decorations
// 6. Add z-index sorting
// 7. Add effects/animations
// 8. Expand to multiple workspaces, tiling layouts
// 9. Optionally hook in real clients or Wayland buffers
